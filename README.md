设计概要
=====
本项目的目的是设计一个基于ARM架构的MCU，并能在上面成功运行两个维度为16的32位向量卷积，其中详细要求如下：
- ALU的设计与实现：要求结构化输入；
- MCU的设计与实现：可以采用行为级输入；
- MCU需要至少支持ADD，SUB，AND，OR，MOV，LDR，STR，B/BL；
- 可在ARM指令集内选择扩展支持更多的指令；
- ALU/MCU结构不限制但是必须严格遵守ARM指令集；
最终成功完成了MCU的设计，并通过了最终的测试，MCU运算速度显著，达到14.8万次卷积每秒。

目标及完成情况
=====
我们的设计目标是设计一个基于ARM架构的MCU，并能在上面成功计算两个维度为16的32位向量卷积，其中MCU采用行为级输入，需要支持ADD，SUB，AND，OR，MOV，LDR，STR，B/BL等基本ARM指令。为了方便运算，我们扩展了乘法指令：MUL和赋值指令：MOV，并自行编写了更高运算速度的乘法器模块；同时，我们也对汇编指令进行了一系列的优化。

最终，我们成功完成了MCU基本指令的测试、卷积运算仿真结果的测试和上板测试，且结果全部正确。上板结果显示，在频率为49MHZ时，我们共花费393个时钟周期完成一次卷积运算，运算速度达14.8万次卷积每秒。

![image](https://github.com/TongZhao1030/MCU/assets/164134563/8b06577f-68ab-4198-9339-dcb305391ddd "上板结果")

关键创新点
=====
指令扩展
-----
我们对基本的ARM指令集进行了扩展。通过对数据通路和控制器逻辑的修改，我们扩展出了MUL指令和MOV指令，当cmd为1101时执行MOV指令，当cmd为1111时执行MUL指令。其中MOV指令是数据处理指令，cond为1110，op为00；由于我们在此算法中只需要将立即数作为操作数，因此I=1，S=0；Rn=0000，Rd为目的寄存器，Src2的低八位为立即数。我们在ALUResult后添加了一个2：1多路选择器，用于直接将立即数存储到目标存储器中，其控制信号为MOV，实现该指令后，我们可以方便地给寄存器赋初值。调整后的数据通路如下：

![image](https://github.com/TongZhao1030/MCU/assets/164134563/148aa570-cc42-48b9-ae79-678b8ee5d1ad "调整后的数据通路")

部分代码如下：

![image](https://github.com/TongZhao1030/MCU/assets/164134563/4b164be8-7985-41d1-9004-9ab8a6fa1882 "代码")
![image](https://github.com/TongZhao1030/MCU/assets/164134563/fedac6de-0949-408e-a230-17ba7edd1d26 "代码")

乘法指令MUL对ALUControl的译码逻辑作出了调整，将其从2位扩展为了3位，同时指定数据处理指令的cmd为1111时执行乘法指令；在优化过程中我们还发现，如果不给乘法加上使能的话，每次ALU运算都要运算一次乘法，会拖慢MCU的整体运算速度。于是我们指定，只有当ALUControl为100时才进行乘法运算，如果不是乘法指令则跳过执行乘法运算。经过此次优化后，MCU的最高频率有小幅上升。代码逻辑如下：

![image](https://github.com/TongZhao1030/MCU/assets/164134563/f5b8f74f-c9ad-4c76-8b8d-8beddb15163b "代码")
![image](https://github.com/TongZhao1030/MCU/assets/164134563/2e5139f6-9ecf-4791-b468-ca4a82899e2f "代码")

乘法优化
-----
我们对乘法运算进行了优化。我们发现任务始终以32位存储数据，所以运算结果始终不会超过32位。而在HDL编程语言中，使用“\*”进行运算，两个32的数相乘会得到64位的结果，而最终我们需要的也是此结果的低32位。因此若采用简单的“\*”运算，则会带来太多不必要的移位运算和加法运算，增加运算开销。我们通过尝试、推理和验证发现，32位有符号数的乘法具有这样的性质：若不产生溢出，则可以直接采用两个乘数的补码进行运算，其乘积的低32位总是我们需要的结果。这是因为，乘法的本质上是移位的加法，由于补码加法的正确性，我们可以推出补码乘法的正确性，而采用补码运算则可以避免我们陷入到冗余的符号判定和编码转换过程中；且我们可以设计一种乘法器，尽量只对低32位进行操作，从而避免对高32位不必要的运算。经查阅资料和推理验证，我们发现，如果将原本的32位数分为两个16位数进行运算，即：

![image](https://github.com/TongZhao1030/MCU/assets/164134563/d07d166a-8dda-43a2-8ee0-0bdfa567ff51#pic_center "运算过程")

这样，我们就可以把第一项直接舍去，从而简化了乘法运算。由此，结合前缀加法器思想的启发，我们可以继续向下推进，把16位数继续拆分成8位数进行运算：

![image](https://github.com/TongZhao1030/MCU/assets/164134563/edb1ddce-12c0-400b-8f48-a774812d9362#pic_center "运算过程")

在此过程中，我们虽然舍去了一些项并缩减了乘法的规模，但增加了乘法的运算和加法的运算，因此无法确定两种乘法器的运算速度相对快慢。在后期的调试优化过程中我们发现，这两种乘法器的开销和运算速度都是一致的，因此最终我们采用了更为轻量级的第一种版本。换用乘法器后，我们的开销得到了缩减，同时频率得到了提升。两个乘法器的模块代码如下：

![image](https://github.com/TongZhao1030/MCU/assets/164134563/4814fa03-95e4-4cdd-a07b-97e1ab39b0a4 "代码")
![image](https://github.com/TongZhao1030/MCU/assets/164134563/0d767cd9-f883-4b66-9452-76632814feab "代码")

汇编指令优化
-----
我们对汇编指令进行了优化，将一些需要重复使用的操作数固定存储在一些寄存器中，另外还优化了一些中间步骤的运算顺序，大幅度减少了从存储器中取操作数到寄存器中的操作，减少了LDR等指令的数量，从而减少了时钟周期。

你可以在test_1.0(test_2.0)/final_project/final_project.srcs/sources_1/new中找到Verilog代码。









